---
description: These rules apply when the user chooses to build the playable using **PixiJS v8**.  They provide guidance on how to structure and optimise your PixiJS code within this repository.
alwaysApply: false
---



## Always apply

- **Create an application:** Use `new PIXI.Application()` with the
  default renderer.  Attach the view (canvas) to a container in
  `index.html` or dynamically create it in `main.js`.
- **Use the Assets API:** Load textures via `PIXI.Assets.load()` or
  manifest bundles.  Avoid loading individual images at runtime.
- **Ticker loop:** Drive your game loop via `app.ticker.add()`.
  Pause the ticker when the ad is not viewable and resume when it
  becomes viewable again.

## Apply intelligently

- **Graphics and sprites:** Use `PIXI.Graphics` to draw simple
  shapes (bars, buttons) instead of raster images.  For complex
  animations, combine small sprites into a spritesheet.
- **Scene graph:** Group related elements in `PIXI.Container` and
  avoid deep nesting to keep rendering efficient.
- **Responsive sizing:** Scale the stage and contents based on
  `mraid.getMaxSize()` or CSS percentages; consider device pixel
  ratio when setting resolution.

## Apply to specific files

- **Files under `src/pixi/`:** Organise PixiJS code here.  Export
  factory functions or classes (e.g. `createGameScene()`) rather than
  instantiating the application on import.  The top‑level `main.js`
  should call these functions after MRAID readiness.
- **`main.js`:** Provide a `setupPixi()` helper that initialises
  PixiJS when the user selects it.  Keep PixiJS code separate from
  other engine options.

## Apply manually

- **LLM guidance:** When in doubt about PixiJS APIs, consult the
  official documentation or the PixiJS LLM guides.  Keep the code
  concise to fit within the playable’s size budget.
- **Texture optimisation:** Compress textures and limit the number
  of frames in animations.  Use tools like TexturePacker to pack
  spritesheets, then load them via the Assets API.

## Always apply

- **Create an application:** Use `new PIXI.Application()` with the
  default renderer.  Attach the view (canvas) to a container in
  `index.html` or dynamically create it in `main.js`.
- **Use the Assets API:** Load textures via `PIXI.Assets.load()` or
  manifest bundles.  Avoid loading individual images at runtime.
- **Ticker loop:** Drive your game loop via `app.ticker.add()`.
  Pause the ticker when the ad is not viewable and resume when it
  becomes viewable again.

## Apply intelligently

- **Graphics and sprites:** Use `PIXI.Graphics` to draw simple
  shapes (bars, buttons) instead of raster images.  For complex
  animations, combine small sprites into a spritesheet.
- **Scene graph:** Group related elements in `PIXI.Container` and
  avoid deep nesting to keep rendering efficient.
- **Responsive sizing:** Scale the stage and contents based on
  `mraid.getMaxSize()` or CSS percentages; consider device pixel
  ratio when setting resolution.

## Apply to specific files

- **Files under `src/pixi/`:** Organise PixiJS code here.  Export
  factory functions or classes (e.g. `createGameScene()`) rather than
  instantiating the application on import.  The top‑level `main.js`
  should call these functions after MRAID readiness.
- **`main.js`:** Provide a `setupPixi()` helper that initialises
  PixiJS when the user selects it.  Keep PixiJS code separate from
  other engine options.

## Apply manually

- **LLM guidance:** When in doubt about PixiJS APIs, consult the
  official documentation or the PixiJS LLM guides.  Keep the code
  concise to fit within the playable’s size budget.
- **Texture optimisation:** Compress textures and limit the number
  of frames in animations.  Use tools like TexturePacker to pack
  spritesheets, then load them via the Assets API.